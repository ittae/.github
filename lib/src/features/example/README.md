# 구조 설명

하나의 feature에 application, data, domain, presentation 계층으로 구분되어 있습니다.

각 계층에 대한 설명은 다음과 같습니다.
- 데이터 계층: 다양한 소스(API, 로컬 데이터베이스 등)의 데이터를 관리하고 데이터 모델 및 저장소 구현을 제공합니다.
- 도메인 계층: 엔터티(간단한 데이터 구조) 및 데이터에 대한 작업을 정의하는 사용 사례/인터랙터를 포함한 비즈니스 논리가 포함되어 있습니다.
- 프레젠테이션 레이어: 상태 관리를 위해 Riverpod를 사용하여 UI와 상태를 관리합니다. 이 레이어에서는 화면과 위젯을 정의하고 사용자가 애플리케이션과 상호 작용하는 방식을 관리합니다.

>모든 feature가 application, data, domain, presentation 폴더를 꼭 갖지 않습니다. 필요한 경우에만 폴더를 만듭니다.

## Application

실제 비즈니스 로직을 포함하는 부분으로, Presentation 계층으로부터 전달된 요청을 처리하고 데이터를 가공하여 반환합니다.

### 만들 수 있는 파일 예시
- example_service.dart
- example_service.g.dart

## Data

DB나 외부 데이터 원본과의 상호 작용을 담당하는 부분, 데이터를 가져오고 저장하는 작업을 수행합니다.

### 만들 수 있는 파일 예시
- example_repository.dart
- example_repository.g.dart

## Domain

애플리케이션 핵심 데이터 구조를 나타내며, DB나 네트워크에서 가져온 데이터를 객체로 변환한 형태입니다.

### 만들 수 있는 파일 예시
- example.dart

## Presentation

사용자 인터페이스(UI)와 비즈니스 로직 간의 중간 계층, UI에서 발생한 이벤트를 처리하고 필요한 데이터를 비즈니스 로직에 전달합니다.

### 만들 수 있는 파일 예시
- example_controller.dart
- example_controller.g.dart
- example_screen.dart
- example_submit_exception.dart (예외가 발생할 수 있는 경우에 추가)

presentation에서는 feature별로 여러 개의 스크린이 생길 수 있다. 입력과 수정, 목록 등
그럴때는 presentation/edit_example_screen, presentation/example_entries_screen, presentation/examples_screen와 같이 폴더를 만들면 된다.

---

# 클린 아키텍처

다양한 아키텍처들이 프로젝트 폴더 구조와 파일의 역할을 계층으로 나누는 것은 관심사의 분리를 위해서이다.

아키텍처가 가져야 하는 시스템은 아래와 같습니다.
1. 프레임워크에 독립적이어야 한다: 제한된 제약 조건에 가두지만 라이브러리에 의존하지 않으면서 프레임워크를 도구로써 사용할 수 있다.
2. 테스트가 가능해야 한다: 사업 규칙(Business rule)은 UI, DB, 웹 서버 또는 기타 외부 요소 없이 테스트할 수 있어야 한다.
3. UI로부터 독립적이어야 한다: 시스템의 다른 부분을 변경하지 않고도 UI는 쉽게 변해야 합니다. 예로 사업 규칙을 변경하지 않으면서 웹 UI를 콘솔 UI로 교체 가능해야 합니다.
4. DB로부터 독립적이어야 한다: 기존에 사용하던 DB를 다른 DB(BigTable, NoSQL, VectorDB 등)로 교체 가능해야 합니다. 사업 규칙이 DB에 묶여있지 않아야 합니다.
5. 외부 기관으로부터 독립적이어야 한다: 실제로 사업 규칙은 외부 세계에 대해 전혀 알지 못해야 합니다.

![The Clean Architecture](/lib/assets/CleanArchitecture.jpg)

## 종속성 규칙

동심원 안으로 깊이 들어갈수록 소프트웨어의 수준은 높아집니다. 바깥쪽 원은 메커니즘들입니다. 내부 원은 정책들입니다.
소스 코드 의존성은 내부(안쪽)만 향해야 합니다. 내부 원의 어떤 것도 바깥쪽 원에 대해 어떤 것도 알 수 없어야 합니다.
바깥쪽 원에 선언된 항목의 이름은 내부 원의 코드에서 언급되어선 안됩니다. 언급되어선 안되는 것들에는 함수, 클래스, 변수, 다른 소프트웨어 엔터티입니다.
마찬가지로 바깥쪽 원에서 사용되는 데이터 형식이 내부 원에서 사용되어선 안됩니다. 특히 이러한 형식들이 바깥쪽 원의 위치한 프레임워크에 의해서 생성되는 경우 더욱 그렇습니다.
바깥쪽 원의 어떤 것도 내부 원에 영향을 미치는 것을 원하지 않습니다.

## Entities

엔터티는 전사적 차원의 사업 규칙을 캡슐화하고 있습니다. 엔터티는 메소드를 가진 객체일 수 있고 데이터 구조 및 기능 집합일 수도 있습니다.
기업의 다양한 애플리케이션에서 사용될 수 있다면 문제가 되지 않습니다. 만일 기업용이 아닌 단일 애플리케이션을 위한거라면 엔터티들은 단일 앱의 비즈니스 객체입니다.
그럴 때는 가장 일반적이고 높은 수준의 규칙을 캡슐화합니다. 외부적인 변화가 있을 때 엔터티들이 변할 가능성은 가장 적습니다.
어떤 구체적인 애플리케이션의 운영 변경이 엔터티 계층에 영향을 주어서는 안됩니다.

## Use Cases

이 계층의 소프트웨어는 애플리케이션 특화 사업 규칙을 포함하고 있습니다. 이는 시스템의 모든 사용 사례를 캡슐화하고 구현합니다.
이러한 사용 사례는 엔터티 간의 데이터 흐름을 조정하고 해당 엔터티가 전사적 차원의 사업 규칙을 사용하여 사용 사례의 목표를 달성하도록 지시합니다.
이 계층의 변경 사항이 엔터티에게 영향을 줄거라고 예상하지 않습니다. 또한 이 계층이 DB, UI, 일반적인 프레임워크와 같은 외부 요소의 변경으로 인해 영향을 받을 것으로 예상하지 않습니다.
그러나 우리는 애플리케이션의 작동에 대한 변경 사항이 사용 사례에 영향을 미치고 이 계층의 소프트웨어에도 영향을 미칠 것으로 예상합니다. 사용 사례의 세부 사항이 변경되면 이 계층의 일부 코드가 확실하게 영향을 받게 됩니다.

## Interface Adapters

이 계층의 소프트웨어는 사용 사례와 엔터티에 가장 편리한 형식에서 DB나 웹 같은 외부 기관에 가장 편리한 형식으로 변환하는 어댑터들의 집합입니다.
Presenters, Views, Controllers가 모두 여기에 속합니다. 모델은 controllers에서 사용 사례로 전달된 다음 presenters와 views로 다시 전달되는 데이터 구조일 가능성이 높습니다.
이 계층에서는 데이터가 엔터티 및 사용 사례에 가장 편리한 형식에서 사용되는 지속성 프레임워크에 가장 편리한 형식으로 변횐됩니다.
이 계층에는 외부 서비스와 같은 일부 외부 형식의 데이터를 사용 사례 및 엔터티에서 사용하는 내부 형식으로 변환하는데 필요한 다른 어댑터도 있습니다.

## Frameworks and Drivers

가장 바깥에 위치한 계층은 일반적으로 DB, 웹 프레임워크 등과 같은 프레임워크와 도구로 구성됩니다. 일반적으로 이 레이어에는 내부의 다음 원과 통신하는 접착 코드 외에는 많은 코드를 작성하지 않습니다.
이 레이어에는 모든 세부 정보가 들어갑니다. 웹은 세부 사항입니다. DB도 세부 사항입니다. 우리는 이러한 것들이 거의 해를 끼치지 않도록 외부에 보관합니다.

### Conclusion

가장 바깥쪽 원은 낮은 수준의 콘크리트 세부 사항입니다. 내부로 들어갈수록 소프트웨어가 더욱 추상화되고 더 높은 수준의 정책이 캡슐화됩니다.
가장 안쪽의 원이 가장 일반적입니다.
